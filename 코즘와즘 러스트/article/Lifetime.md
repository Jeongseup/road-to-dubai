
# 라이프타임 (Lifetime)

모든 참조자는 라이프타임을 갖고 있어.대부분의 경우 참조자의 라이프타임이 암묵적으로 추론돼!(다음에 나오는 규칙에 따라서!)
추론에 실패한 경우, 제네릭 라이프타임 파라미터를 명시해서 런타임에 참조자의 유효성을 확실히 하게 돼. 그것이 Rust의 lifetime 문법이야. 
## 라이프타임이 뭐야?

라이프타임은 참조자가 유효한 범위를 나타내는 거야. 모든 참조자는 라이프타임을 갖고 있어. 대부분의 경우에는 컴파일러가 알아서 추론해주지만, 가끔은 우리가 직접 명시해줘야 할 때도 있어.

## 라이프타임 생략 규칙

러스트는 몇 가지 상황에서는 라이프타임을 생략할 수 있게 해줘. 주요 규칙은 이래:

1. 각 참조자 파라미터는 고유한 라이프타임 파라미터를 가져.
2. 입력 라이프타임 파라미터가 하나뿐이면, 그 라이프타임이 모든 출력 라이프타임 파라미터에 적용돼.
3. 메서드의 경우, 첫 번째 파라미터가 &self나 &mut self면 그 라이프타임이 모든 출력 라이프타임 파라미터에 적용돼.

이 규칙을 만족하지 못하면 우리는 lifetime을 명시를 해줘야해.


## 왜 라이프타임이 필요해?

라이프타임의 주요 목적은 댕글링 참조자(dangling references)를 방지하는 거야. 댕글링 참조자란 이미 해제된 메모리를 가리키는 참조자를 말해. 이런 상황이 발생하면 프로그램이 크래시될 수 있어서 정말 위험해.

예를 들어, 이런 코드를 한번 볼까?

```rust
{
    let r;
    {
        let x = 5;
        r = &x;
    }
    println!("r: {}", r);
}
```

이 코드는 컴파일되지 않아. 왜냐하면 `x`가 내부 스코프를 벗어나면서 해제되는데, `r`은 그 해제된 메모리를 참조하려고 하기 때문이야.

## 라이프타임 명시하기

대부분의 경우에는 컴파일러가 라이프타임을 추론할 수 있어. 하지만 가끔은 우리가 직접 명시해줘야 할 때가 있어. 라이프타임을 명시할 때는 작은따옴표(')를 사용해.

예를 들어, 이런 함수를 볼까?

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

여기서 `'a`는 제네릭 라이프타임 파라미터야. 이 함수는 "x와 y 중에서 더 긴 문자열의 참조를 반환할 건데, 반환된 참조의 라이프타임은 x와 y의 라이프타임 중 더 짧은 쪽과 같아"라고 말하고 있는 거야.

## 구조체에서의 라이프타임

구조체에서 참조자를 필드로 사용할 때도 라이프타임을 명시해줘야 해. 이렇게:

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}
```

이 구조체는 "part 필드의 참조자는 적어도 ImportantExcerpt 인스턴스만큼은 유효해야 해"라고 말하고 있는 거야.



## 정적 라이프타임

'static이라는 특별한 라이프타임이 있어. 이건 프로그램의 전체 수명 동안 유효한 참조를 나타내. 문자열 리터럴은 항상 'static 라이프타임을 가져.

```rust
let s: &'static str = "Hello, world!";
```

## 마무리

라이프타임 문법은 Rust가 추론하지 못하는 라이프타임을 명시해주는 문법이라고 할 수 있어! 
