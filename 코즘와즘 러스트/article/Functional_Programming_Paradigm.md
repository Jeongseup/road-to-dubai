# 함수형 프로그래밍 패러다임

함수형 프로그래밍(FP) 패러다임은 복잡한 문제를 작고 순수한 함수들로 나누고 이를 조합해 해결하는 방식이야. 이 접근법은 여러 가지 중요한 장점을 가져와. 특히 병렬 처리, 동시성, 비동기 프로그래밍 같은 현대 프로그래밍의 핵심 개념들을 다루는 데 매우 효과적이지. 이제 이런 개념들을 자세히 살펴보고, 함수형 프로그래밍이 어떻게 이를 지원하는지 알아보자.

## 1. 병렬 처리 (Parallel Processing)

병렬 처리는 여러 작업을 동시에 수행하는 걸 말해. 이건 멀티코어 프로세서를 효율적으로 활용해서 프로그램의 성능을 크게 향상시킬 수 있어.

### 병렬 처리의 개념

- **정의**: 여러 계산 작업을 동시에 수행하는 것
- **목적**: 전체 처리 시간을 줄이고 시스템 자원을 효율적으로 사용하는 것
- **예시**: 대량의 데이터를 처리할 때 데이터를 여러 부분으로 나눠 각각 다른 코어에서 동시에 처리하는 것

### 함수형 프로그래밍과 병렬 처리

함수형 프로그래밍은 병렬 처리를 구현하기 쉽게 만들어줘. 그 이유는:

1. **불변성**: 데이터가 변하지 않으므로 여러 스레드에서 동시에 안전하게 접근할 수 있어.
2. **순수 함수**: 부작용이 없어서 어떤 순서로 실행해도 결과가 같아. 이는 작업을 쉽게 분배할 수 있게 해줘.
3. **고차 함수**: `map`, `reduce` 같은 함수들은 본질적으로 병렬화하기 쉬워.

Rust에서 병렬 처리 예시:

```rust
use rayon::prelude::*;

fn main() {
    let numbers: Vec<i32> = (1..1000000).collect();
    
    let sum: i32 = numbers.par_iter()  // 병렬 이터레이터 사용
                          .sum();      // 자동으로 병렬 처리됨
    
    println!("Sum: {}", sum);
}
```

이 예시에서 `rayon` 라이브러리의 `par_iter()`를 사용해 벡터를 병렬로 처리하고 있어. 함수형 접근 덕분에 코드가 간단하면서도 효율적이지.

## 2. 동시성 (Concurrency)

동시성은 여러 작업을 번갈아가면서 처리하는 것을 말해. 이건 I/O 바운드 작업에서 특히 유용하지.

### 동시성의 개념

- **정의**: 여러 작업을 동시에 진행되는 것처럼 보이게 하는 것
- **목적**: 시스템 자원을 효율적으로 사용하고, 응답성을 높이는 것
- **예시**: 웹 서버에서 여러 클라이언트의 요청을 동시에 처리하는 것

### 함수형 프로그래밍과 동시성

함수형 프로그래밍은 동시성 프로그래밍을 더 안전하고 예측 가능하게 만들어줘:

1. **상태 공유 최소화**: 불변 데이터와 순수 함수를 사용하므로 공유 상태로 인한 문제가 줄어들어.
2. **부작용 제어**: 부작용이 명확히 구분되어 있어 동시성 관련 버그를 찾기 쉬워.
3. **합성 가능성**: 작은 동시성 단위를 쉽게 조합해 더 큰 시스템을 만들 수 있어.

Rust에서 동시성 예시:

```rust
use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```

이 예시에서는 채널을 사용해 스레드 간 안전하게 메시지를 주고받고 있어. 함수형 접근을 사용하면 이런 동시성 패턴을 더 쉽게 구현할 수 있지.

## 3. 비동기 프로그래밍 (Asynchronous Programming)

비동기 프로그래밍은 작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있게 해주는 프로그래밍 모델이야.

### 비동기 프로그래밍의 개념

- **정의**: 작업의 시작과 완료 사이에 다른 작업을 수행할 수 있게 하는 프로그래밍 모델
- **목적**: I/O 바운드 작업에서 시스템 자원을 효율적으로 사용하고 응답성을 높이는 것
- **예시**: 네트워크 요청을 보내고 응답을 기다리는 동안 다른 작업을 처리하는 것

### 함수형 프로그래밍과 비동기 프로그래밍

함수형 프로그래밍은 비동기 프로그래밍을 더 쉽고 안전하게 만들어줘:

1. **모나드와 합성**: `Future`나 `Promise` 같은 개념을 모나드로 표현해 쉽게 합성할 수 있어.
2. **부작용 제어**: 비동기 작업의 부작용을 명확히 구분하고 관리할 수 있어.
3. **코드 가독성**: 콜백 지옥을 피하고 더 선형적인 코드를 작성할 수 있어.

Rust에서 비동기 프로그래밍 예시:

```rust
use tokio;

#[tokio::main]
async fn main() {
    let result = fetch_data().await;
    println!("Result: {:?}", result);
}

async fn fetch_data() -> Result<String, Box<dyn std::error::Error>> {
    let response = reqwest::get("https://www.example.com").await?;
    let body = response.text().await?;
    Ok(body)
}
```

이 예시에서는 `async/await` 문법을 사용해 비동기 작업을 동기 코드처럼 쉽게 작성하고 있어. 함수형 접근을 사용하면 이런 비동기 로직을 더 쉽게 구성하고 관리할 수 있지.

## 4. 함수형 프로그래밍의 추가적인 장점

지금까지 살펴본 병렬 처리, 동시성, 비동기 프로그래밍 외에도 함수형 프로그래밍은 여러 가지 장점을 가지고 있어:

### 4.1. 코드의 가독성과 유지보수성

함수형 프로그래밍은 코드를 더 읽기 쉽고 유지보수하기 쉽게 만들어줘:

- **선언적 프로그래밍**: '무엇을' 할지 명확히 표현해서 코드의 의도를 쉽게 파악할 수 있어.
- **작은 순수 함수**: 기능을 작은 순수 함수로 나누면 각 함수의 역할을 쉽게 이해하고 테스트할 수 있어.
- **합성 가능성**: 작은 함수들을 조합해 복잡한 동작을 만들 수 있어 코드 재사용성이 높아져.

예를 들어, 다음과 같은 명령형 코드를:

```rust
let mut result = Vec::new();
for i in 0..100 {
    if i % 2 == 0 {
        result.push(i * i);
    }
}
```

이렇게 함수형으로 바꿀 수 있어:

```rust
let result: Vec<_> = (0..100)
    .filter(|&i| i % 2 == 0)
    .map(|i| i * i)
    .collect();
```

두 번째 버전이 더 간결하고 의도를 명확히 표현하고 있지?

### 4.2. 테스트 용이성

함수형 프로그래밍은 테스트를 쉽게 만들어줘:

- **순수 함수**: 입력에 대해 항상 같은 출력을 반환하므로 예측 가능하고 테스트하기 쉬워.
- **부작용 분리**: 부작용이 명확히 구분되어 있어 mock 객체나 stub을 사용하기 쉬워.
- **불변성**: 상태 변경이 없어서 테스트 케이스 간 간섭이 없어.

예를 들어:

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[test]
fn test_add() {
    assert_eq!(add(2, 3), 5);
    assert_eq!(add(-1, 1), 0);
    assert_eq!(add(0, 0), 0);
}
```

이 함수는 순수 함수라서 테스트하기 매우 쉽지?

### 4.3. 버그 감소

함수형 프로그래밍은 여러 가지 방식으로 버그를 줄여줘:

- **불변성**: 상태 변경으로 인한 버그가 줄어들어.
- **타입 시스템**: 강력한 타입 시스템을 통해 많은 버그를 컴파일 시점에 잡아낼 수 있어.
- **부작용 제어**: 부작용을 명시적으로 관리해 예상치 못한 동작을 줄일 수 있어.

예를 들어, Rust의 `Option`과 `Result` 타입을 사용하면 null 참조 오류나 예외 처리 누락 같은 흔한 버그를 방지할 수 있어:

```rust
fn divide(a: f64, b: f64) -> Option<f64> {
    if b == 0.0 {
        None
    } else {
        Some(a / b)
    }
}

fn main() {
    match divide(10.0, 2.0) {
        Some(result) => println!("Result: {}", result),
        None => println!("Cannot divide by zero"),
    }
}
```

이 코드에서는 0으로 나누는 경우를 명시적으로 처리하고 있어서 런타임 에러를 방지할 수 있지.

### 4.4. 모듈성과 재사용성

함수형 프로그래밍은 코드의 모듈성과 재사용성을 높여줘:

- **작은 순수 함수**: 작고 독립적인 함수들은 다양한 상황에서 재사용하기 쉬워.
- **고차 함수**: 함수를 값으로 다룰 수 있어 더 유연한 추상화가 가능해.
- **불변 데이터 구조**: 불변 데이터는 여러 부분에서 안전하게 공유할 수 있어.

예를 들어, 다음과 같은 고차 함수를 생각해 봐:

```rust
fn compose<A, B, C, F, G>(f: F, g: G) -> impl Fn(A) -> C
where
    F: Fn(A) -> B,
    G: Fn(B) -> C,
{
    move |x| g(f(x))
}

fn main() {
    let add_one = |x| x + 1;
    let double = |x| x * 2;
    let add_one_then_double = compose(add_one, double);
    
    println!("Result: {}", add_one_then_double(3));  // Prints: Result: 8
}
```

이런 식으로 함수를 조합해서 새로운 함수를 만들 수 있어. 이렇게 하면 코드 재사용성이 높아지고 새로운 기능을 쉽게 만들 수 있지.
