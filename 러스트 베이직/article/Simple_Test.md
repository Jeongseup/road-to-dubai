# 함수형 프로그래밍을 활용한 간단한 테스트 주도 개발 (TDD)

테스트 주도 개발(Test-Driven Development, TDD)은 소프트웨어 개발 방법론 중 하나로, 실제 코드를 작성하기 전에 테스트 코드를 먼저 작성하는 방식이야. 함수형 프로그래밍(Functional Programming, FP)과 결합하면 TDD를 더 쉽고 효과적으로 수행할 수 있어. 이제 이 두 개념을 어떻게 조합하고 실제 개발에 적용할 수 있는지 살펴보자.

## 1. 함수형 프로그래밍과 TDD의 시너지

함수형 프로그래밍은 다음과 같은 특성으로 TDD와 잘 어울려:

1. **순수 함수**: 동일 입력에 대해 항상 같은 출력을 반환하므로 테스트가 예측 가능하고 반복 가능해.
2. **불변성**: 상태 변경이 없어 테스트 간 간섭이 최소화돼.
3. **명시적인 데이터 흐름**: 함수의 입력과 출력이 명확해 테스트 케이스 작성이 쉬워.
4. **합성 가능성**: 작은 함수들을 조합해 복잡한 동작을 만들 수 있어, 단위 테스트부터 통합 테스트까지 다양한 수준의 테스트를 쉽게 구성할 수 있어.

비즈니스 로직단 함수의 테스트는 계속 작성해야할 수 있지만, 순수함수를 잘 만들어놓으면 테스트 한번만 해도 계속 견고한 로직을 합성해나갈 수 있어! 

## 2. TDD 사이클 in 함수형 스타일

TDD는 보통 Red-Green-Refactor 사이클을 따라가. 함수형 프로그래밍을 활용하면 이 사이클을 더 효과적으로 수행할 수 있어:

1. **Red**: 실패하는 테스트 작성
   - 함수의 시그니처(입력과 출력 타입)를 먼저 정의해.
   - 예상되는 동작을 명시적으로 기술해.

2. **Green**: 테스트를 통과하는 최소한의 코드 작성
   - 순수 함수로 구현해 부작용을 최소화해.
   - 가능한 한 작은 단위의 함수로 나눠 구현해.

3. **Refactor**: 중복 제거, 코드 개선
   - 고차 함수를 활용해 중복을 제거해.
   - 불변 데이터 구조를 사용해 리팩토링 중 발생할 수 있는 부작용을 방지해.

## 3. 실제 예시: 간단한 계산기 구현

함수형 스타일로 TDD를 적용해 간단한 계산기를 구현해보자. Rust를 사용할 거야.

### 3.1 덧셈 기능 구현

먼저 덧셈 기능에 대한 테스트를 작성해보자:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
        assert_eq!(add(-1, 1), 0);
        assert_eq!(add(0, 0), 0);
    }
}
```

이제 이 테스트를 통과하는 최소한의 코드를 작성해:

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

### 3.2 곱셈 기능 추가

곱셈 기능에 대한 테스트를 추가해보자:

```rust
#[test]
fn test_multiply() {
    assert_eq!(multiply(2, 3), 6);
    assert_eq!(multiply(-1, 1), -1);
    assert_eq!(multiply(0, 5), 0);
}
```

그리고 이 테스트를 통과하는 코드를 작성해:

```rust
fn multiply(a: i32, b: i32) -> i32 {
    a * b
}
```

### 3.3 리팩토링: 고차 함수 도입

이제 덧셈과 곱셈 연산을 추상화해서 고차 함수로 만들어보자:

```rust
fn operate<F>(a: i32, b: i32, op: F) -> i32
where
    F: Fn(i32, i32) -> i32,
{
    op(a, b)
}

fn add(a: i32, b: i32) -> i32 {
    operate(a, b, |x, y| x + y)
}

fn multiply(a: i32, b: i32) -> i32 {
    operate(a, b, |x, y| x * y)
}
```

이렇게 하면 새로운 연산을 추가할 때 `operate` 함수를 재사용할 수 있어 코드 중복을 줄일 수 있어.

## 4. 함수형 TDD의 이점

1. **테스트 용이성**: 순수 함수는 테스트하기 쉽고, 목(mock)이나 스텁(stub)이 거의 필요 없어.
2. **리팩토링 안전성**: 불변성과 순수 함수 덕분에 리팩토링 시 부작용이 최소화돼.
3. **병렬 테스팅**: 순수 함수는 상태를 공유하지 않아 병렬로 테스트를 실행할 수 있어.
4. **문서화**: 함수형 코드는 자체로 명확해서 테스트가 좋은 문서 역할을 해.
5. **버그 감소**: 불변성과 순수 함수로 인해 상태 관련 버그가 줄어들어.

## 실전 팁

1. **속성 기반 테스트 활용**: 함수형 프로그래밍은 속성 기반 테스트와 잘 어울려. QuickCheck 같은 라이브러리를 사용해봐.
2. **타입 시스템 활용**: 가능한 한 강력한 타입 시스템을 활용해 컴파일 시점에 많은 버그를 잡아내.
3. **작은 함수 지향**: 함수를 작게 유지하고 한 가지 일만 하도록 해. 이렇게 하면 테스트와 재사용이 쉬워져.
4. **REPL 활용**: 가능하다면 REPL(Read-Eval-Print Loop)을 활용해 빠르게 함수를 테스트하고 실험해봐.

## 결론

함수형 프로그래밍과 TDD는 서로 잘 어우러지는 개념이야. 순수 함수, 불변성, 명시적인 데이터 흐름 등의 특성이 테스트 작성과 유지보수를 쉽게 만들어줘. 이 방식을 적용하면 더 안정적이고 유지보수가 쉬운 코드를 작성할 수 있어. 
